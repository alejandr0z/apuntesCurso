¬øQu√© es la terminal?

La terminal es una herramienta indispensable que cualquier persona en la tecnolog√≠a debe conocer üëÄ. 
Es importante porque:
Te da flexibilidad üìè. Con unos pocos comandos, puedes hacer mucho.
Es mucho m√°s veloz que una interfaz üíª.
Es tu √∫nica opci√≥n si no hay interfaz üòÜ, como para configurar un servidor remoto.
Puedes invocar demonios üëø. Hay que tener cuidado con los comandos.
Espec√≠ficamente, la terminal es una interfaz gr√°fica muy sencilla que simula una l√≠nea de comandos:
TERMINAL: Ventana que muestra el promt. este aloja la shell.
SHELL O LINEA DE COMANDOS: es un programa que toma los comandos y los pasa al sistema operativo para hacer algo
Programa que ejecuta los comandos. Hay varios tipos de shell, pero sirven para lo mismo. La m√°s comunes son 
bash shell o Z shell. En este curso, usaremos la primera üçé.
Es importante comenzar a usar Linux üòü.
Un comando es un programa que se puede ejecutar desde la terminal.

SISTEMA DE ARCHIVOS EN LA TERMINAL 
    (como esta constituida el arbol)

    * / --> Es la raiz del sistema de archivos

COMANDOS TERMINAL, MANIPULANDO ARCHIVOS Y DIRECTORIOS

    * pwd --> para ver la ubicaci√≥n en la que estamos    
    * ls --> para listar 
    * ls -l --> me lista los archivos con su tama√±o en bites
    * ls -lh --> me lista los archivos con su tama√±o entendible por el ser humano
    * ls -a --> Mostrar todos los archivos, incluso los ocultos
    * ls -la --> Ver todos los archivos incluso los ocultos
    * ls -lS --> lista y ordena directorios y archovis por tama√±o
    * ls -lr --> lista y ordena directorios y archovis en orden inverso al orden alfabetico
    * cd --> para cambiar de directorio
    * cd .. --> me lleva una carpeta atras
    * cd /carpeta a la que quiero ir --> para avanzar una carpeta adelante
    * cd / --> para ir directo al directorio home o root
    * cd mnt --> para ir a las carpetas de windows
    * cd ~ --> me lleva a mi carpeta home
    * mkdir nombreArchivo --> para crear una carpeta 
    * sudo mkdir --> crear un directorio con permiso de administrador
    * touch nombreArchivoQueQuieroCrear --> para crear un archivo
    * cat archivoQueQuieroAbrir --> para ver en consola un archivo
    * tree --> Para ver archivos, Este despliega todo los directorios como un arbol
    * tree -L nivelQueQuieroProfundizar --> Para ver archivos, Este despliega todo los directorios como un arbol
    * man app que quiero ver su manual --> para ver las instrucciones de la aplicacion    
    * help <comando> --> muestra una ayuda del comando
    * info <comando> --> para ver info del comando
    * whatis <comando> --> muestra una info resumida del comando 
    * mv archivoQueQUieroMover carpetaAlaQueVoyAmover --> para mover un archivo a otro directorio 
    * mv archivoQueQUieroMover nuevoNombre --> para cambiar de nombre a un archivo 
    * rm nombreArchivoQueQuieroBorrar.extension --> para borrar un solo archivo
    * rm -d nombreCarpetaVacia --> Para borrar una carpeta vacia
    * rm -r nombreCarpetaQueQuieroBorrar --> para borrar una carpeta llena 
    * rm -ri nombreCarpetaQueQuieroBorrar --> para borrar una carpeta llena de forma recursiva 
    * rm -rf nombreCarpetaQueQuieroBorrar --> para borrar una carpeta llena MUY PELIGROSA BORRA TODO
        * -i (de interactive) te pregunta si est√°s seguro de eliminar el archivo
        * -r (de recursive) elimina todo lo que est√© dentro de una carpeta
        * -f (de force) fuerza a borrar todo.
    * file nombreArchivo--> me da la informaci√≥n acerca del archivo que quiero
    * cp nombreDelArchivo nombreDeLaCopia --> para copiar archivos (este lo haria en el mismo directorio)
    * cp nombreDelArchivo nombreDeLaCopia --> para copiar archivos (este lo haria en el mismo directorio)
    * cp nombreDelArchivo ruta/nombreDeLaCopia --> para copiar archivos (este lo haria en el directorio que elija)
    
QUE ES UN COMANDO 
    un comando pueden ser 4 cosas
    1. Un programa ejecutable
    2. Un comando de utilidad de la shell. Esto es un programa en s√≠ mismo, que puede tener funciones.
         Ejemplo cd
    3. Una funci√≥n de shell. Son funciones de shell externas al comando de utilidad. Ejemplo mkdir
    4. Un alias. Un ejemplo es ls

    * type <comando>: Nos permite conocer que tipo de comando es ü§î
    * alias nombreQueLeDoyAmiALias="<secuencia de comandos>": Nos permite crear comandos. Son temporales,
         se borran al cerrar la terminal üë∂üèº Ej: alias ada="cd home/ale/"

WILDCARDS 
    Las wildcards o comodines son una serie de caracteres especiales que nos permiten encontrar patrones 
    o realizar b√∫squedas m√°s avanzadas. Es aplicable para archivos y directorios.

    Las wildcards te sirven para realizar seccionamiento de archivos o directorios, ademas de ls los 
    wildcards tambien pueden usarse con cualquier comando que realice la manipulaci√≥n de archivos como mv, 
    cp y rm.

    por ejemplo buscar todos los archivos que terminen con .txt o todos los archivos que sean html

Tipos de wildcards
    Buscar todo (*)
    El asterisco te ayuda a buscar toda la informaci√≥n dentro de una carpeta, pero puedes limitar su uso. 
    Si por ejemplo quieres buscar los archivos que tengan una extensi√≥n ‚Äú.png‚Äù, escribes:
    
        * ls *.txt --> busca todas las coincidencias que terminan en .txt
        * ls *.html --> busca todas las coincidencias que terminan en .html
        * ls -l *.png --> busca todas las coincidencias que terminan en .png
        * ls datos* --> busca todas las coincidencias con datos

    Buscar por cantidad de caracteres (?)
        Si dentro de tus archivos tuvieras una especie de c√≥digo para guardar tus fotos, algo as√≠ como ‚Äúfoto1.png‚Äù, ‚Äúfoto2.png‚Äù, ‚Äúfoto3.png‚Äù, etc. En este caso, sabemos que primero tenemos el string ‚Äúfoto‚Äù, luego un solo n√∫mero y por √∫ltimo la extensi√≥n ‚Äú.png‚Äù.

        Si quisieras buscar esas fotos escribir√≠as:
        * ls -l foto?.png --> busca todos las coincidencias con foto al inicio y 1 caracter diferente al final
        * ls datos? --> busca todos las coincidencias con datos al inicio y 1 caracter diferente al final

        Aqu√≠ est√°s indicando:
        Busca todo lo que comience por la cadena de caracteres ‚Äúfoto‚Äù
        Que inmediatamente despu√©s tenga un solo caracter
        Y que al final tenga la cadena de caracteres ‚Äú.png‚Äù
        
        Pero si sabes que no tiene un solo caracter, sino que tiene varios, entonces escribes tantos 
        signos de interrogaci√≥n como caracteres existan. Por ejemplo, si quieres buscar las fotos que
        tengan esta estructura ‚Äúfoto11.jpg‚Äù, escribes:
        * ls -l foto??.jpg
        * ls datos??? --> busca todas las coincidencias con datos al inicio y 3 caracteres diferntes al final

        Tambi√©n puedes combinar wildcards. Por ejemplo, si sabes que tus fotos siguen esta especie de c√≥digo, 
        pero no sabes que extensi√≥n tienen, escribes:

        * ls -l foto?.*

        Aqu√≠ est√°s indicando:
        Busca todo lo que comience por ‚Äúfoto‚Äù
        Que inmediatamente despu√©s tenga un solo caracter
        Y que tenga lo que sea despu√©s del punto

    Buscar por caracteres espec√≠ficos ([])
        Si quieres buscar por varios caracteres espec√≠ficos se usan corchetes. Para utilizarlos tienes que colocar dentro de los corchetes los caracteres que quieres buscar.

        Por ejemplo, si quisieras buscar los archivos que comiencen por las letras ‚Äúc‚Äù o ‚Äúi‚Äù, entonces escribes:
        
        * ls [ad]* --> creo una clase para buscar archivos que inicien con a o con d en este caso
        * ls -l [ci]*

        Lo que indica el comando es que busque los archivos que comiencen por la letra ‚Äúc‚Äù o por la letra ‚Äúi‚Äù 
        y que tengan lo que sea por delante. Cuando buscamos con esta wildcard ten en cuenta que es case
         sensitive, por lo que la letra ‚Äúi‚Äù no es lo mismo que la letra ‚ÄúI‚Äù.

        * ls -l [cCiI]*ls -l foto[2-6]*

    Por √∫ltimo, si quieres buscar por rango de n√∫meros tambi√©n tienes que usar esta wildcard. 
    Para hacerlo, escribe el rango de n√∫meros que quieres buscar separados por un guion.

        * ls -l foto[2-6]*

        Lo que indica ese comando es:

        Busca todo lo que comience por la cadena de texto ‚Äúfoto‚Äù
        Que justo despu√©s tenga un n√∫mero entre el 2 y el 6
        Y que tenga lo que sea por delante.

        
        * ls [[:upper:]]* --> busca todas las coincidencias que inicien con mayuscula
        * ls -d [[:upper:]]* --> busca los directorios que inician con mayuscula
        * ls -d [[:lower:]]* --> busca los directorios que iinician con minuscula

    Por ejemplo: para pasar las imagenes de una carpeta que esta en windows a linux con una willcard
        voy a la carpeta que tengo la imagen y hago 
        mv *.jpg ~/ale/carpetaEnUbuntu

ENTRADAS Y SALIDAS DE LA TERMINAL

    Qu√© son las entradas y salidas de la terminal
    En la consola nosotros generamos una entrada cuando escribimos y una salida casi siempre que ejecutamos un comando.

    A las entradas t√≠picamente se les suele llamar Standard Input y a las salidas Standard Output, adem√°s se les suele abreviar como stdin
    y stdout respectivamente.

    Qu√© son file descriptors
    Los file descriptors son n√∫meros que identifican un recurso. Funciona asociando un n√∫mero con una acci√≥n, archivo o programa, 
    en el caso de la shell tenemos 3 file descriptors:

    El 0 es el stdint o estadar Input
    El 1 es el stdout o estandar output
    El 2 es el stderr o Standard Error.

    * C√≥mo usar el operador de redirecci√≥n (>)
        A veces queremos guardar la informaci√≥n de una salida porque nos puede interesar almacenar lo que esa salida contiene.
        Veamos el siguiente ejemplo, si utilizas el comando:
            ls -l
            Lo que sucede aqu√≠ es que le diste un Standard Input (el comando) y obtuviste un Standard Output (la lista de archivos).

        Si quieres que el Standard Output no vaya a la consola sino hacia un archivo, entonces puedes usar 
            operacionQueQUieroHacer directorioOarchivoQueQuieroMAndar > seguido del nombre del archivo en el que quieres guardar la salida.
                Ejemplo:  ls apuntesCurso > textoContieneLoQueEstaEnApuntesCurso.txt

    * C√≥mo concatenar (>>)
        Suponiendo que ya tienes el archivo textoContieneLoQueEstaEnApuntesCurso.txt y ahora tambi√©n quieres guardar la informaci√≥n de 
        la carpeta de documentos, entonces no puedes volver a ejecutar:

    ls -l > output.txt
    Esto lo que har√° es reescribir el contenido del documento, lo que necesitas es concatenar el contenido del documento con el de la salida, para eso ejecutas:

    ls -l >> output.txt
    image.png
    Como puedes ver, la salida del comando ls -l se concaten√≥ con la salida del comando ls -l ./SecretosDeEstado. Te puedes dar cuenta porque la palabra total se repite dos veces.

    Por cierto, esa palabra total es el tama√±o total de la carpeta en kilobytes y dice que la carpeta SecretosDeEstado pesa 0, porque los archivos y carpetas vac√≠as no ocupan espacio.

    Redirecci√≥n de errores (2>|2>&1)
    El operador de redirecci√≥n por defecto solo redirecciona el file descriptor 1 (es decir, el Standard Output). Pero, ¬øqu√© tal si queremos redirigir un error? Pues tenemos que especificar que queremos el Standar Error, que tiene el file descriptor 2.

    Vamos a generar un error ejecutando un comando que saldr√° mal para redirigirlo a un archivo llamado ‚Äúerror.txt‚Äù.

    image.png
    En este caso la opci√≥n ‚Äú√±‚Äù no existe, por lo que produce un error.

    Tambi√©n podemos especificar que no importa lo que pase si me da un Standar Ouput o un Standar Error, igual tiene que guardar la salida en un archivo. Esto lo hacemos as√≠:

    ls -l > output.txt 2>&1
    La orden 2>&1 significa que debe redirigir el file descriptor 2 y el file descriptor 1.

    image.png
    En la primera ejecuci√≥n del comando, se ejecuta correctamente y guarda el Standar Output, pero en la segunda ejecuci√≥n, el comando falla y guarda el Standar Error.

    Tabla de operadores
    Operador	Funci√≥n
    >	Redirecciona la salida. Por defecto redirecciona el Standar Output
    >>	Concatena la salida con lo que ya tenga el archivo a donde se est√° redirigiendo la salida
    2>	Redirecciona el file descriptor 2 (En este caso Standar Error)
    2>&1	Redirecciona el file descriptor 2 y 1
    <   Redirecciona el file error

REDIRECCIONES: PIPE OPERATOR 

    Es uno de los operadores mas √∫tiles que existen, ya que nos permite poner varios comandos, tales que la salida 
    de uno es la entrada del siguiente üì§.

    * echo <texto> genera un stdout con el texto que tenemos, osea solo muestra el texto que le pase.
    * less <archivo> --> sirve para visualizar lo que hay en un documento
        Puedo buscar dentro de este usando / <lo que quiero buscar)
    * cat <archivo1> <archivo2> muestra los dos archivos concatenados üí©.
    * cat < archivo, abro el standar input  

    * el comando sort me sirve para ordenar

    * El pipe operator | hace que el stdout de un comando sea el stdin de otro comando. Por ejemplo ls -lh | less
    
    * tee hace algo parecido a >, pero dentro de los pipe¬¥s, osea genera un documento
        Ejemplo ls -lh |  tee output.txt | less . 
        Se puede poner en medio, pero se ignora porque se sigue pasando.
    
    * lolcat --> cambia el texto de color 
    * cowsay "Texto" es un comando que imprime una vaca que dice algo JAJAJAJAJ üêÆ.
        EJEMPLOS:
        * cowsay -f calvin "texto" | lolcat
        * cowsay -f dragon "texto" 
        * cowsay -f dragon-and-cows "texto" | lolcat
        * cowsay -f tux "texto" | lolcat
        * cowsay -f rocket "texto" | lolcat
    * echo "Texto" | lolcat esto lo imprime con colores bonitos üòÇ


OPERADORESDE CONTROL
    Son simbolos reservados por la terminal que permiten ejecutar mas de un comando o encadenarlos 
    se pueden correr sincronamente o de forma asincrona, incluso con condicionales.

    EJECUTAR COMANDOS DE MANERA SINCRONA (Uso ;)
        osea se ejecutan uno detras de otro 
               
        Ejemplo: ls; mkdir holaPrueba; cal

        * cal es para mostrar un calendario en la terminal.
        * date muestra la fecha 
        * echo muestra el texto que se le pasa 
            Ejemplo: echo "HOLA"

    EJECUTAR COMANDOS DE MANERA ASINCRONA (Uso &)
        Se ejecuta cada comando al tiempo osea en forma paralela en diferente hilo de mi procesador
        
        Ejemplo: ls & cal & mkdir holaPrueba

    EJECUTAR COMANDOS DE MANERA CONDICIONAL AND (Uso && para hacer el "y")
        Se ejecuta un comando y si se cumple se ejecuta el siguiente 

        Ejemplo: mkdir test && cd test && touch test.txt

        si existe un error en cualquiera de los comandos el siguiente no se ejecuta
    
    EJECUTAR COMANDOS DE MANERA CONDICIONAL OR (Uso || para hacer el "o")

        Ejemplo: mkdir test || cd hsdfjsdjf || cd test
    
    COMBINANDO OPERADORES DE CONTROL

        Ejemplo: cd ~eres || cd ~/apuntesCurso/ && mkdir prueba


COMO SE MANEJAN LOS PERMISOS
    Los permisos son las capacidades que tiene cada usuario dentro del sistema operativo, no todos los usuarios
    pueden hacer todas las acciones sobre ciertos archivos y carpetas.

    TIPOS DE ARCHIVOS

        * - --> es un achivo normal, como un documento de texto, una foto, un video, etc.
        * d --> Por directory es un directorio
        * l --> es un link simbolico
        * b --> es un archivo de bloque especial, son archivos que manejan la informaci√≥n de los 
            bloques de datos como una usb, la informaci√≥n de un disco duro       

    TIPOS DE MODOS 

        PERMISOS DE USUARIO 

        Los siguientes caracteres se leen de 3 en 3, por cada uno de los tipos de usuario.

        Owner
        El due√±o del archivo, si no se ha cambiado, es quien lo creo y tiene mayor jerarqu√≠a sobre los otros 3. Le corresponden los primeros 3 caracteres de los permisos.

        Group
        Se puede crear grupos de usuarios para darle a todos o varios los mismos permisos. A estos usuarios le corresponden el cuarto, quinto y sexto caracter de los permisos de usuarios y tienen mayor jerarqu√≠a que el √∫ltimo.

        World
        Tambi√©n llamado ‚Äúotros‚Äù, es cualquier otro usuario que no pertenezca a un grupo de usuario y tampoco sea el due√±o, este tiene la menor jerarqu√≠a.

        Son los tipos de permisos dependiendo quien es el que actua sobre ellos, cada una de las estas categorias 
        tiene 3 tipos de permiso 
            r --> read
            w --> write
            x --> execute

            cada permiso esta activo si tiene un 1 y un 0 si no se puede manipular
            estos permisos se representan en modelo 3 bits o sistema octal

                Sistema octal 
                    el bit de la derecha tiene un valor de 4
                    el del medio un valor de 2
                    y el de la izquierda un valor de 1 

        * DUE√ëO (Soy yo)
            rwx --> 1 1 1
            en modo octal seria un 7
        * GRUPO (Cuando comparto con alg√∫n grupo o persona)
            r-x --> 1 0 1 
            en modo octal seria un 5
        *  WORLD (Cuando comparto con cualquier persona que no sea la anterior)
            r-x --> 1 0 1
            en modo octal seria un 5
        
        Los permisos se escriben en ese orden rwx. Para indicar que el permiso no est√° disponible, se escribe un guion

        Ejemplos: 
            * drwxr-xr-x 
                d porque es un directorio, 
                rwx osea el owner (due√±o) puede leer, escribir y ejecutar
                r-x osea el group puede leer y ejecutar 
                r-x el world solo puede leer y ejecutar 

            * -rw-r--r--
                - Esto es un archivo normal, como una im√°gen o un video
                rw- osea el owner puede solo leer y escribir
                r-- el group solo puede leer 
                r-- el world solo puede leer 

    
        MODO SIMB√ìLICO
            * u --> permisos solo para el usuario
            * g --> permisos solo para el grupo
            * o --> permisos solo para para otras personas (es el world)
            * a --> permisos para todos

    EJERCICIOS
        Convierte los siguientes permisos a s√≠mbolos y en su representaci√≥n num√©rica:

        * De un directorio, el due√±o tiene permiso de lectura y escritura, el grupo tiene permisos de escritura 
          y ejecuci√≥n y world no tiene permisos.
            drw--wx---

        * De un enlace simb√≥lico el due√±o tiene todos los permisos, el grupo y world s√≥lo de lectura.
            lrwxr--r--

        * De un archivo comun todos tienen todos los permisos, pero el world no tiene permiso de ejecuci√≥n.
            -rwxrwxrw-


MODIFICANDO PERMISOS DE LA TERMINAL 

    MANEJO DE USUARIO ROOT 
    Este usuario tiene acceso total al sistema

    Para cambiar de usuario en ubuntu uso
    * su root --> me pide la contrase√±a y es la misma que puse antes 
    * sudo su --> lo uso para cambiar de usuario en WSL ya que la anterior no esta activa 
        debo activarla por seguridad, tener la contrase√±a usuario con la de root diferentes 

        para cambiar la contrase√±a de root voy a root y le doy 
        * passwd --> me pide la nueva contrase√±a

    * sudo rm texto.txt --> usar sudo me da los permisos de root pero sin estar en usuario root

    --> Con el comando chmod podemos cambiar los permisos de los archivos de dos formas, una es usando los s√≠mbolos
        (rwx) y otra es con el sistema octal.

        C√≥mo cambiar los permisos de un archivo (chmod)
        Es bastante sencillo cambiar los permisos de forma simb√≥lica. Para esto, hay que escribir despu√©s del comando
        chmod el s√≠mbolo del usuario, luego el operador y por √∫ltimo el permiso que quieres agregar o quitar.

        chmod [simboloDelUsuario][operador][permiso] [archivoParaCambiarSusPermisos]

              owner	     |  group	|   others
        -----------------|----------|------------
            u (de user)	 |    g	    |     o
        -----------------|----------|------------
              Operador	 |       Funci√≥n
        -----------------|-----------------------
                 +	     |   A√±ade un permiso
                 -	     |   Quita un permiso
                 =	     |   Asigna un permiso

    MODIFICANDO PERMISOS CON MODO OCTAL 

        * > texto.txt --> Puedo creear un archivo de texto solo colocando el comando > (ac√° cre√© el archivo texto.txt)
        * cat > texto.txt --> puedo usar el editor mas sencillo usando este comando, para salir es ctrl + d 
        
        Ejemplo: si veo los permiso de mi archivo de texto original son (uso ls -l)
            -rwxr-xr-x
            ahora voy a cambiar los permisos con chmod

        * chmod 757 texto.txt --> lo uso para cambiar los permisos del archivo, le doy valores en modo octal para owner, group y world
        
        Ejemplo: ahora los nuevos permisos son 
            -rwxrwxrwx
    
    MODIFICANDO PERMISOS CON MODO SIMB√ìLICO

        * chmod u-x,g-w-x,o-w texto.txt

    CAMBIAR LA CONTRASE√ëA
        * passwd --> ingreso este comando y voy a poder cambiar la contrase√±a 
        * ¬øQu√© hacer en caso de olvidar una contrase√±a?Si est√°s usando Windows Subsystem for Linux (wsl) 
            y se te olvid√≥ la contrase√±a del root. Sigue estos pasos: 
                Abre el cmd de windows y ejecuta este comando wsl --user root.
                Esto har√° que se inicie en la terminal wsl con el usuario root.
                Luego ejecuta el comando passwd root el cual te permitir√° cambiar la contrase√±a del usuario root.
                Ya con esto puedes volver a la terminal de wsl y volver a ejecutar el comando su root.

    * whoami --> me da la info del usuario en el que estoy
    * id --> me da la informacion de los grupos a los que pertenezco 

    CAMBIAR AL PROPIETARIO (chown)
        Puede que no te quieras hacer responsable de tus archivos, as√≠ que se los quieres dejar a alguien m√°s. 
        Para eso usa el comando chown Change Owner. La sintaxis es muy simple:

        * chown [usuarioAlQuePertenecer√°] [archivo]

VARIABLES DE ENTORNO
    La terminal, shell y linea tiene de comandos tienen una configuraci√≥n, y a ellas puedo acceder con las 
    variables de entorno.

    LINKS SIMB√ìLICO
        Son un tipo de archivo que hacen referencia a un lugar, se los borra igual que cualquier otro archivo,
        b√°sicamente es un acceso directo desde terminal üìÅ
        
        * ln -s <ruta> <Nombre> 

        * printenv --> nos muestra todas las variables de entorno que tenemos configuradas üìî

        * echo $<variables> --> esto nos sirve para imprimir una variable en particular
            Ejemplo: * echo $HOME --> es nuestro HOME de usuario
                     * echo $PATH --> tiene todas las rutas donde se encuentran los binarios en los que se ejecuta 
                        nuestro sistema. Hay varios manejadores de paquetes para binarios, pero no todas las veces 
                        se agregan a PATH, y se deben agregar a mano.

                        o tambien para verlas mas ordenadas
                     * echo $PATH | tr : \\n
                     * echo $BASH_VERSION --> para saber la versi√≥n de bash que tengo 
                     * echo $SHELL --> Direcci√≥n de la shell que estoy usando
    
    MODIFICAR LAS VARIABLES DE ENTORNO
        En HOME, existe un archivo que se llama .bashrc que es donde est√° nuestra configuraci√≥n de Bash. 
        Lo podemos abrir con VS Code para modificarlo. en este archivo .bashrc puedo agregar los ALIAS, 
        agregar o modificar VARIABLES DE ENTORNO y tambien puedo agregar una nueva ruta a la variable PATH,
        osea cuando agregue nuevos binarios.
        si estuviera en mac deberia editar el archivo .zshrc que es el bash en mac

            para abrirlo hago 
            * code .bashrc 

            * code <archivo> para abrir un archivo de texto en VS Code desde la terminal.        

        PARA CREAR ALIAS
            * alias <nombre>="comando" --> para crear un alias

            Es muuuy importante tener cuidado con los alias, nunca hay que nombrar un alias como un comando ya existente üòü

            Para ver los alias que tengo en lista en la terminal le doy el comando 
                * alias

            Tambien es posible saber si un comando en especifico es un alias o no. Con el comando type podremos saber esto
            Ejemplo: * type <alias que quiero saber si existe> 
        
        PARA CREAR O MODIFICAR VARIABLES DE ENTORNO
            
            Ejemplo:  PLATZI="Hola amigos"
        
        PARA AGREGAR UNA NUEVA RUTA A LA VARIABLE PATH

            * PATH=$PATH:<ruta>

        IMPORTANTE: SIEMPRE QUE HAGA UNA MODIFICACION EN EL ARCHIVO .bashrc DEBO EJECUTAR EN LA TERMINAL EL 
        COMANDO bash SOLO, AS√ç SE ACTUALIZA TODO.

COMANDOS DE BUSQUEDA 
    Nos sirven para encontrar archivos y directorios, y filtrarlos dependiendo su extension, Nombre, ubicaci√≥n, etc
    Ejemplo: cuando queremos buscar archivos.log que son archivos de texto plano que recopilan iformaci√≥n de un 
    archivo en ejecuci√≥n por ejemplo google chrome crea un archivo.log para guardar que p√°gina visita, si hay 
    algun error en el sistema.

    PARA BUSCAR ARCHIVOS BINARIOS
        * which <archivo> --> nos busca los archivos binarios en la ruta de PATH
        (binario es un programa que se va a ejecutar)

        Ejemplo: which code --> me da la direccion donde esta VSC 

    BUSQUEDA CON FIND 

        * find [rutaDesdeDondeEmpezarBuscar] [opciones]

        * find <rutaInicialDeBusqueda> -name nombreDelArchivo --> nos permite encontrar un archivo
          seg√∫n la ruta indicada y el nombre.

        SEGMENTAR POR EL NOMBRE (-name)
            Ejemplo: voy a buscar en mi carpeta home todos los archivos que tenga una extensi√≥n ‚Äú.png‚Äù.

                * find ./ -name *.png
                El punto indica que debe empezar desde la carpeta en la que est√° y la opci√≥n -name es para 
                especificar el nombre que debe buscar.

            * find <rutaInicialDeBusqueda> -name *.extencion --> nos permite buscar los archivos seg√∫n 
            la extencion desde la ruta indicada, en este caso se usa wildcards
            
                * find <rutaInicialDeBusqueda> -name *.extencion | less --> para realizar lo mismo de arriba 
                pero de forma mas ordenada 

        SEGMENTAR POR EL TIPO (-type)
            Tambi√©n puedo segmentar por el tipo, si es un archivo o si es un directorio utilizando la 
            opci√≥n -type, el cual acepta f para archivos, d para directorios y l para enlaces simb√≥licos.

            Si quiero usar m√°s de una opci√≥n lo separo por comas.

            Ejemplo: find ./ -type f -name "f*"
                Esto me muestra todos los archivos que comiencen con la letra ‚Äúf‚Äù.
            
            Ejemplo: buscando archivos y directorios
                find ./ -type f,d -name "D*"

            * find <rutaInicialDeBusqueda> -type fd -name nombreDelArchivo --> type nos permite
              segmentar por f (files) o d (directorios)

        SEGMENTAR POR TAMA√ëO (-size)
            Con la opci√≥n -size puedo segmentar por tama√±o ingresando el peso que quiero buscar. 
            Esta opci√≥n tiene un uso un tanto especial. Primero que todo hay que colocar la unidad 
            de peso c para byte, k para Kilobyte, M para Megabyte y G para Gygabyte.

            Ejemplos:
                * find ./ -size 4k
                Buscar√° los archivos que pesen exactamente 4kb. Pero claro, atinar el peso exacto de un 
                archivo no es para nada sencillo, as√≠ que podemos especificar que sea ese peso en adelante
                con el s√≠mbolo + o de ese peso para abajo con el s√≠mbolo -

                * find ./ -size +4k
                Busca los archivos que pesen 4kb o m√°s.

                * find ./ -size -4k
                Busca los archivos que pesen 4kb o menos.

            * find <rutaInicialDeBusqueda> -size tama√±oYUnidadDeMedida --> busqueda por tama√±o del archivo

    BUSCAR VACIOS (-empty)
        Para buscar los archivos vac√≠os uso la opci√≥n empty, no hay que especificarle nada, solo escribirla.

        Ejemplo: find ./ -type d -empty
        busca todas las carpetas vac√≠as

    LIMITAR LA BUSQUEDA (-maxdepth -mindepth)
        Puede que no quiera buscar en absolutamente todas las carpetas del sistema, sino que quiero 
        √∫nicamente un pedacito. Para eso limito la profundidad de carpetas a la que el comando debe buscar, 
        esto se hace con la opci√≥n -maxdepth seguido de la profundidad.
        * find ./ -type d -maxdepth 2

        a veces ya conozco m√°s o menos la estructura de mis carpetas, as√≠ que quiero
        saltar niveles, por lo que le asigno una profundidad m√≠nima al comando.
        * find ./ -type d -mindepth 2

    Es recomendable pasar el output al comando less
    * find ./ | less


    EJERCICIOS
        Buscar todos los archivos .txt desde el home y guardarlo en un archivo.txt y mostar que fue creado
        correctamente
            SOLUCION
            * find ./ -type f -name "*.txt" | tee misArchivos.txt && echo "Archivos guardados"
            * find ~ -name "*.txt" > archivosDeTexto.txt && cowsay "Se guardaron los archivos :)"|lolcat
                archivosDeTexto.txt|lolcat
        
        Busca tus archivos mayores a 100Mb, con una profundidad m√°xima de 4, que comiencen por la letra c.
            * find /mnt/c/Users/aleja/OneDrive/Documentos -type f -name c* -size 1M | less
        
        Busca los archivos que tengan extensi√≥n ‚Äú.pdf‚Äù con una profundidad m√≠nima de 2.
            * find /mnt/c/Users/aleja/OneDrive -type f -name *.pdf -mindepth 1 | less
        
        Busca todas las carpetas que comiencen por la letra ‚ÄúA‚Äù con una profundidad m√°xima de 5, que est√©n vac√≠as.
            * find /mnt/c/Users/aleja -type d -name b* -maxdepth 5 | less
        
        Busca todo lo que tenga una letra ‚Äúj‚Äù que pese m√°s de 1b. Luego guarda la salida en un archivo llamado
        ‚ÄúLosArchivosJ.txt‚Äù y cuando termine de hacer todo eso imprime un mensaje que diga 
        ‚ÄúComando terminado con √©xito‚Äù.
            * find /mnt/c/Users/aleja/OneDrive/Documentos -type f -name C* -size +1c | tee archivos.txt | echo "archivos creados correctamente" | lolcat 
    
USANDO EL COMANDO GREP
    Grep permite encontrar coindidencias de una b√∫squeda dentro de un archivo de texto 

    ¬øQu√© significa grep?
    ‚ÄúGrep‚Äù significa Global Regular Expression Print.

    El comando grep utiliza regex (Regular Expression) para realizar su b√∫squeda

    La sintaxis es sencilla
        * grep [Expresi√≥nRegular] [archivoDondeBuscar]
        osea [greap loQueQuieroBuscar] [archivoDondeBuscar]

    buscar una palabra dentro del archivo de texto movies.csv
        * grep Towers movies.csv

    IGNORAR CASE SENSITIVE (-i)
        Puede que quiera buscar la palabra ‚ÄúAction‚Äù pero eso dar√° exclusivamente las coincidencias con la ‚ÄúA‚Äù
        may√∫scula. Esto lo puedo ignorar con la opci√≥n -i, que buscar√° independientemente de si la letra ‚ÄúA‚Äù 
        es may√∫scula o min√∫scula
            * grep -i Action movies.csv

    CONTAR OCURRENCIAS (-c)
        Si quiero saber cu√°ntas veces se repite una palabra, uso la opci√≥n -c seguida de la palabra 
        que quiero buscar.
            * grep -c Drama movies.csv

    EXCLUIR UNA EXPRESI√ìN (-v)
        Para saber cu√°les son los resultados que NO coinciden con la expresi√≥n regular, uso la opci√≥n -v.

            Por ejemplo, si quiero contar todas las pel√≠culas que no son de drama, escribo:
            * grep -cv Drama movies.csv

    LIMITAR LA BUSQUEDA (-m)
        Para no buscar en todo el archivo, sino las primeras ocurrencias, puedo limitar la b√∫squeda en 
        l√≠neas con la opci√≥n -m seguida del n√∫mero de l√≠neas que quiero encontrar.

            Por ejemplo, si quiero buscar las primeras 10 l√≠neas que concuerden con la palabra ‚ÄúFan‚Äù escribo
            * grep -m 10 Fan movies.csv

    CONTAR CUANTAS LINEAS HAY 
        * wc <archivo>
            Ejemplo: wc movies.csv
            la primera columna me indica cuantas lienas tiene el archivo, la segunda columna cuantos caracteres
            tiene, la tercera me indica cuantos bits tiene y la ultima es el nombre.

            * wc -l movies.csv --> indica cuantas lineas hay 
            * wc -w movies.csv --> indica cuantas palabras hay
            * wc -c movies.csv --> indica cuantos bytes hay


UTILIDADES DE REDIRECCIONES
    * ifconfig --> me muestra informacion de nuestra red 

    * ping --> me sirve para ver si una p√°gina esta activa 
        * Limitar los paquetes enviados (-c)
          Para limitar la cantidad de paquetes que envio, uso la opci√≥n -c seguida del n√∫mero de paquetes por enviar
          Ejemplo: ping -c 4 www.google.com
        
        * Especificar el tama√±o de los paquetes (-s)
          Para probar la conectividad con paquetes de diferentes tama√±os utilizo la opci√≥n -s
          seguido del tama√±o del paquete que deseo usar. El tama√±o debe ser en bytes
          Ejemplo: ping -s 20 www.google.com

    * curl --> me sirva para traer todo el html de una p√°gina web
        puedo obtener archivos que proporcione un sitio web o direcci√≥n IP con el comando curl
        Este mostrar√° la informaci√≥n que haya encontrado en la consola.
        Ejemplo: curl www.google.com 

        si quiero guardar este html lo que hago es 
        Ejemplo. curl www.google.com > index.html

    * wget --> me descarga automaticamente el index.html de una p√°gina de internet
        Ejemplo: wget www.google.com

    * traceroute --> 
        Cuando nos conectamos a una p√°gina en internet no nos conectamos directamente a los servidores 
        en los que est√° almacenada esa p√°gina, sino que primero se pasa por otros servidores que son 
        como intermediarios entre la computadora y el servidor.
        Ejemplo: traceroute www.google.com

    * netstat -i --> me muestra los dispositivos de red 
    


COMPRIMIENDO ARCHIVOS TAR Y ZIP

     Puedo crear archivos comprimidos .zip o .tar desde la terminal. ü§ñ
     .tar se usa mucho en repositorios. Para comprimir

    FORMATO .TAR Y .TAR.GZ

        COMPRIMIENDO CON .tar y .tar.gz

            El formato .tar es un tipo de compresi√≥n bastante usado en UNIX. Originalmente era utilizado para almacenar 
            informaci√≥n en cintas magn√©ticas, as√≠ que est√° hecho especialmente para comprimir los archivos de forma lineal.

            * .tar [opciones] [nombreDelArchivoComprimido] [archivoAComprimir]
                donde c ‚Üí compress, v ‚Üí verbose (ver lo que comprimio), f‚Üí file
                Ejemplo: tar -cvf toCompress.tar toCompress/

            * .tgz es aun mejor, se usa el mismo comando de .tar pero con la bandera z‚Üízip 
                * tar cvzf <nombreCarpetaAcomprimir>.tgz <archivos>.
                    Ejemplo: tar -cvf comprimido.tgz toCompress
                Usa el algoritmo gzip que es muy eficiente para comprimir
        
        PARA DESCOMPRIMIR .tar y .tar.gz

            Para descomprimirlo, uso el mismo comando pero con la bandera x ‚Üí decompress en lugar de c ‚Üí compress.
            Para que funcione, debo descomprimir usando el mismo tipo de compresi√≥n (tar o zip).

                Ejemplo: descomprimiendo .tar
                    * tar -xvf <archivoAcomprimido>.tar
                
                Ejemplo: descomprimiendo .tgz
                    * tar xvfz <archivoAcomprimido>.tgz
    
    FORMATO .RAR
    
        PARA COMPRIMIR CON .rar
            * rar a <nombreCarpetaAcomprimir>.rar <archivoAcomprimir>
        
        PARA COMPRIMIR CON CONTRASE√ëA
            * rar a -p <nombreCarpetaAcomprimir>.rar <archivoAcomprimir>

        PARA DESCOMPRIMIR EN .rar
            * unrar x <nombreCarpetaAdescomprimir.rar>

        PARA VER QUE TIENE UN RAR 
            * rar l <archivoAcomprimido>.rar
        
    
    FORMATO ZIP

        PARA COMPRIMIR CON .zip
            * zip -r <nombreCarpetaAcomprimir>.rar <archivoAcomprimir>

        PARA DESCOMPRIMIR CON .zip
            * unzip <nombreCarpetaAdescomprimir.rar>

MANEJO DE PROCESOS 
    

